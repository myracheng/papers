# Learning to Infer Graphics Programs from Hand-Drawn Images

Kevin Ellis, Daniel Ritchie, Armando Solar-Lezama, Joshua B. Tenenbaum. [Learning to Infer Graphics Programs from Hand-Drawn Images.](https://arxiv.org/pdf/1707.09627.pdf) NIPS 2017. 99 cites.

## abstract
convert drawings into graphics programs written in latex. combine deep learning and program synthesis. learn CNN that proposes drawing primitives, which are a spec of what the graphics program draws. then use program synthesis for that part. 

## intro
key observation: requires 2 steps.
1) inferring what objects are in an image
2) identify higher-level visual concepts to describe how they are drawn (e.g. pattern that can be described with two nested loops)

probabilistic inference in a genreative model. program produces drawing commands (`spec`: what is drawn, but not the structure of how to draw it), and then these are used to form an issue. 

spec is infered using stochastic search. use NN to amortize cost of inferring specs from images, and Bias-Optimal Search to amortize cost of synthesizing programs

`bias-optimal search`: guaranteed to find a solution in $\sigma$ after searching for a certain amount of time, where $t(\sigma)$ is the time to verify that $\sigma$ contains a soltuion
- QQ why is this significant?
    - so the algo explores the whole space, but spends most time in regions that the policy judges are most promising
    - basically running searches in paralel.

so 2 things: 1) model for symbolic programs from perceptual input 2) use learning to amortize cost of program synthesis

## inferring spec
deep network architecure
- one command at a time, conditioned on what has drawn so far. 
- CNN, predict distribution over next drawing command
- ways to have noise (from hand drawing), leniency for errors, etc.

## synthesizing graphics programs
- use DSL. 
- define cost program based on its length. use Sketch, which requires a finite program space (bound the depth)
    - QQ MC could also use NEAR?

### search policy for program synthesis
- becomes much faster
- offer additional constraint on the structure of the program.
- search policy has input spec, and predicts distribution over search problems (i.e. sets to search over)
- trade-off between size of search space and likeliness that it contains good programs
- to minimize runtime, learn P_bias by picking policy that minimizes the time to solve a corpus of program synthesis problems
- training corpus generated by synthesizing programs for hand drawings and then minimize using gradient descent

- experiments: compared to Sketch, deepcoder, RNN from iamges to programs, and oracle

## applications
- program synthesizer can correct errors from the execution spec proposal network
- quantifying similarity between drawings


QQ how do ppl pick these domains? what domain should we pick?
